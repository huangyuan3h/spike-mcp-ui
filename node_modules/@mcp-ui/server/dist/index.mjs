const h = "ui/resourceUri", o = "mcpui.dev/ui-", d = `var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MCPUIAppsSdkAdapter {
  constructor(config = {}) {
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "messageIdCounter", 0);
    __publicField(this, "originalPostMessage", null);
    this.config = {
      logger: config.logger || console,
      hostOrigin: config.hostOrigin || window.location.origin,
      timeout: config.timeout || 3e4,
      intentHandling: config.intentHandling || "prompt"
    };
  }
  /**
   * Initialize the adapter and monkey-patch postMessage if Apps SDK is present
   */
  install() {
    if (!window.openai) {
      this.config.logger.warn("[MCPUI-Apps SDK Adapter] window.openai not detected. Adapter will not activate.");
      return false;
    }
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Initializing adapter...");
    this.patchPostMessage();
    this.setupAppsSdkEventListeners();
    this.sendRenderData();
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter initialized successfully");
    return true;
  }
  /**
   * Clean up pending requests and restore original postMessage
   */
  uninstall() {
    for (const request of this.pendingRequests.values()) {
      clearTimeout(request.timeoutId);
      request.reject(new Error("Adapter uninstalled"));
    }
    this.pendingRequests.clear();
    if (this.originalPostMessage) {
      try {
        const parentWindow = window.parent ?? null;
        if (parentWindow) {
          parentWindow.postMessage = this.originalPostMessage;
        }
        this.config.logger.log("[MCPUI-Apps SDK Adapter] Restored original parent.postMessage");
      } catch (error) {
        this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to restore original postMessage:", error);
      }
    }
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter uninstalled");
  }
  /**
   * Monkey-patch parent.postMessage to intercept MCP-UI messages
   * and forward non-MCP-UI messages to the original postMessage
   */
  patchPostMessage() {
    const parentWindow = window.parent ?? null;
    this.originalPostMessage = parentWindow?.postMessage?.bind(parentWindow) ?? null;
    if (!this.originalPostMessage) {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] parent.postMessage does not exist, installing shim only");
    } else {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Monkey-patching parent.postMessage to intercept MCP-UI messages");
    }
    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
      if (this.isMCPUIMessage(message)) {
        const mcpMessage = message;
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] Intercepted MCP-UI message:", mcpMessage.type);
        this.handleMCPUIMessage(mcpMessage);
      } else {
        if (this.originalPostMessage) {
          this.config.logger.debug("[MCPUI-Apps SDK Adapter] Forwarding non-MCP-UI message to original postMessage");
          if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
            const targetOrigin = targetOriginOrOptions ?? "*";
            this.originalPostMessage(message, targetOrigin, transfer);
          } else {
            this.originalPostMessage(message, targetOriginOrOptions);
          }
        } else {
          this.config.logger.warn("[MCPUI-Apps SDK Adapter] No original postMessage to forward to, ignoring message:", message);
        }
      }
    };
    try {
      if (parentWindow) {
        parentWindow.postMessage = postMessageInterceptor;
      }
    } catch (error) {
      this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to monkey-patch parent.postMessage:", error);
    }
  }
  /**
   * Check if a message is an MCP-UI protocol message
   */
  isMCPUIMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
  }
  /**
   * Handle incoming MCP-UI messages and translate to Apps SDK actions
   */
  async handleMCPUIMessage(message) {
    this.config.logger.debug("[MCPUI-Apps SDK Adapter] Received MCPUI message:", message.type);
    try {
      switch (message.type) {
        case "tool":
          await this.handleToolMessage(message);
          break;
        case "prompt":
          await this.handlePromptMessage(message);
          break;
        case "intent":
          await this.handleIntentMessage(message);
          break;
        case "notify":
          await this.handleNotifyMessage(message);
          break;
        case "link":
          await this.handleLinkMessage(message);
          break;
        case "ui-lifecycle-iframe-ready":
          this.sendRenderData();
          break;
        case "ui-request-render-data":
          this.sendRenderData(message.messageId);
          break;
        case "ui-size-change":
          this.handleSizeChange(message);
          break;
        case "ui-request-data":
          this.handleRequestData(message);
          break;
        default:
          this.config.logger.warn("[MCPUI-Apps SDK Adapter] Unknown message type:", message.type);
      }
    } catch (error) {
      this.config.logger.error("[MCPUI-Apps SDK Adapter] Error handling message:", error);
      if (message.messageId) {
        this.sendErrorResponse(message.messageId, error);
      }
    }
  }
  /**
   * Handle 'tool' message - call Apps SDK tool
   */
  async handleToolMessage(message) {
    if (message.type !== "tool")
      return;
    const { toolName, params } = message.payload;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    try {
      if (!window.openai?.callTool) {
        throw new Error("Tool calling is not supported in this environment");
      }
      const result = await this.withTimeout(
        window.openai.callTool(toolName, params),
        messageId
      );
      this.sendSuccessResponse(messageId, result);
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'prompt' message - send followup turn
   */
  async handlePromptMessage(message) {
    if (message.type !== "prompt")
      return;
    const prompt = message.payload.prompt;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    try {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("Followup turns are not supported in this environment");
      }
      await this.withTimeout(
        window.openai.sendFollowUpMessage({ prompt }),
        messageId
      );
      this.sendSuccessResponse(messageId, { success: true });
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'intent' message - convert to prompt or ignore based on config
   */
  async handleIntentMessage(message) {
    if (message.type !== "intent")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    if (this.config.intentHandling === "ignore") {
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Intent ignored:", message.payload.intent);
      this.sendSuccessResponse(messageId, { ignored: true });
      return;
    }
    const { intent, params } = message.payload;
    const prompt = \`\${intent}\${params ? \`: \${JSON.stringify(params)}\` : ""}\`;
    try {
      if (!window.openai?.sendFollowUpMessage) {
        throw new Error("Followup turns are not supported in this environment");
      }
      await this.withTimeout(
        window.openai.sendFollowUpMessage({ prompt }),
        messageId
      );
      this.sendSuccessResponse(messageId, { success: true });
    } catch (error) {
      this.sendErrorResponse(messageId, error);
    }
  }
  /**
   * Handle 'notify' message - log only
   */
  async handleNotifyMessage(message) {
    if (message.type !== "notify")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.config.logger.log("[MCPUI-Apps SDK Adapter] Notification:", message.payload.message);
    this.sendAcknowledgment(messageId);
    this.sendSuccessResponse(messageId, { acknowledged: true });
  }
  /**
   * Handle 'link' message - not supported in Apps SDK environments
   */
  async handleLinkMessage(message) {
    if (message.type !== "link")
      return;
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    this.sendErrorResponse(messageId, new Error("Navigation is not supported in Apps SDK environment"));
  }
  /**
   * Handle size change - no-op in Apps SDK environment
   */
  handleSizeChange(message) {
    this.config.logger.debug("[MCPUI-Apps SDK Adapter] Size change requested (no-op in Apps SDK):", message.payload);
  }
  /**
   * Handle generic data request
   */
  handleRequestData(message) {
    const messageId = message.messageId || this.generateMessageId();
    this.sendAcknowledgment(messageId);
    this.sendErrorResponse(messageId, new Error("Generic data requests not yet implemented"));
  }
  /**
   * Setup listeners for Apps SDK events
   */
  setupAppsSdkEventListeners() {
    window.addEventListener("openai:set_globals", () => {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Globals updated");
      this.sendRenderData();
    });
  }
  /**
   * Gather render data from Apps SDK and send to widget
   */
  sendRenderData(requestMessageId) {
    if (!window.openai)
      return;
    const renderData = {
      toolInput: window.openai.toolInput,
      toolOutput: window.openai.toolOutput,
      widgetState: window.openai.widgetState,
      locale: window.openai.locale || "en-US",
      theme: window.openai.theme || "light",
      displayMode: window.openai.displayMode || "inline",
      maxHeight: window.openai.maxHeight
    };
    this.dispatchMessageToIframe({
      type: "ui-lifecycle-iframe-render-data",
      messageId: requestMessageId,
      payload: { renderData }
    });
  }
  /**
   * Send acknowledgment for a message
   */
  sendAcknowledgment(messageId) {
    this.dispatchMessageToIframe({
      type: "ui-message-received",
      payload: { messageId }
    });
  }
  /**
   * Send success response
   */
  sendSuccessResponse(messageId, response) {
    this.dispatchMessageToIframe({
      type: "ui-message-response",
      payload: { messageId, response }
    });
  }
  /**
   * Send error response
   */
  sendErrorResponse(messageId, error) {
    const errorObj = error instanceof Error ? { message: error.message, name: error.name } : { message: String(error) };
    this.dispatchMessageToIframe({
      type: "ui-message-response",
      payload: { messageId, error: errorObj }
    });
  }
  /**
   * Dispatch a MessageEvent to the iframe (widget)
   * Simulates messages that would normally come from the parent/host
   */
  dispatchMessageToIframe(data) {
    const event = new MessageEvent("message", {
      data,
      origin: this.config.hostOrigin,
      source: null
    });
    window.dispatchEvent(event);
  }
  /**
   * Wrap a promise with timeout
   */
  async withTimeout(promise, requestId) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error(\`Request timed out after \${this.config.timeout}ms\`));
      }, this.config.timeout);
      this.pendingRequests.set(requestId, {
        messageId: requestId,
        type: "generic",
        resolve,
        reject,
        timeoutId
      });
      promise.then((result) => {
        clearTimeout(timeoutId);
        this.pendingRequests.delete(requestId);
        resolve(result);
      }).catch((error) => {
        clearTimeout(timeoutId);
        this.pendingRequests.delete(requestId);
        reject(error);
      });
    });
  }
  /**
   * Generate a unique message ID
   */
  generateMessageId() {
    return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
  }
}
let adapterInstance = null;
function initAdapter(config) {
  if (adapterInstance) {
    console.warn("[MCPUI-Apps SDK Adapter] Adapter already initialized");
    return true;
  }
  adapterInstance = new MCPUIAppsSdkAdapter(config);
  return adapterInstance.install();
}
function uninstallAdapter() {
  if (adapterInstance) {
    adapterInstance.uninstall();
    adapterInstance = null;
  }
}
`;
function p(e) {
  const t = e ? JSON.stringify(e) : "{}";
  return `
<script>
(function() {
  'use strict';
  
  ${d}
  
  // Override auto-init from runtime and initialize with provided config
  if (typeof window !== 'undefined') {
    // If the functions are not defined, just return, we can't do anything.
    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {
      console.warn('[MCPUI-Apps SDK Adapter] Adapter runtime not found with the correct methods. Adapter will not activate.')    
      return;
    }
    
    // If auto-init is enabled, initialize with config from server 
    if (!window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter(${t});
    }
    
    // Expose functions globally
    if (typeof window.MCPUIAppsSdkAdapter === 'undefined') {
      window.MCPUIAppsSdkAdapter = {
        init: initAdapter,
        initWithConfig: () => initAdapter(${t}),
        uninstall: uninstallAdapter,
      };
    }
  }
})();
<\/script>
`.trim();
}
const g = `var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const PROTOCOL_VERSION = "2025-11-21";
class McpAppsAdapter {
  constructor(config = {}) {
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "messageIdCounter", 0);
    __publicField(this, "originalPostMessage", null);
    __publicField(this, "parentWindow", null);
    __publicField(this, "hostCapabilities", null);
    __publicField(this, "hostContext", null);
    __publicField(this, "initialized", false);
    // Current render data state (similar to window.openai in Apps SDK)
    __publicField(this, "currentRenderData", {});
    this.config = {
      logger: config.logger || console,
      timeout: config.timeout || 3e4
    };
  }
  install() {
    this.parentWindow = window.parent;
    this.config.logger.log("[MCP Apps Adapter] Checking parent window...");
    this.config.logger.log("[MCP Apps Adapter] window.parent exists:", !!this.parentWindow);
    this.config.logger.log("[MCP Apps Adapter] window.parent === window:", this.parentWindow === window);
    if (!this.parentWindow || this.parentWindow === window) {
      this.config.logger.warn("[MCP Apps Adapter] No parent window detected. Adapter will not activate.");
      return false;
    }
    this.config.logger.log("[MCP Apps Adapter] Initializing adapter...");
    this.patchPostMessage();
    window.addEventListener("message", this.handleHostMessage.bind(this));
    this.performInitialization();
    this.config.logger.log("[MCP Apps Adapter] Adapter initialized successfully");
    return true;
  }
  /**
   * Performs the MCP Apps SEP initialization handshake:
   * 1. Send ui/initialize request with adapter info
   * 2. Receive host capabilities and context
   * 3. Send ui/notifications/initialized notification
   * 4. Dispatch ready event to MCP-UI app
   */
  async performInitialization() {
    const jsonRpcId = this.generateJsonRpcId();
    const initPromise = new Promise((resolve, reject) => {
      this.pendingRequests.set(String(jsonRpcId), {
        messageId: "init",
        type: "init",
        resolve: (result) => {
          const res = result;
          this.hostCapabilities = res?.hostCapabilities ?? null;
          this.hostContext = res?.hostContext ?? null;
          this.initialized = true;
          this.sendJsonRpcNotification("ui/notifications/initialized", {});
          if (this.hostContext) {
            if (this.hostContext.theme)
              this.currentRenderData.theme = this.hostContext.theme;
            if (this.hostContext.displayMode)
              this.currentRenderData.displayMode = this.hostContext.displayMode;
            if (this.hostContext.locale)
              this.currentRenderData.locale = this.hostContext.locale;
            if (this.hostContext.viewport?.maxHeight)
              this.currentRenderData.maxHeight = this.hostContext.viewport.maxHeight;
          }
          this.sendRenderData();
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-iframe-ready"
          });
          resolve();
        },
        reject: (error) => {
          this.config.logger.error("[MCP Apps Adapter] Initialization failed:", error);
          reject(error);
        },
        timeoutId: setTimeout(() => {
          this.pendingRequests.delete(String(jsonRpcId));
          this.config.logger.warn("[MCP Apps Adapter] Initialization timed out, proceeding anyway");
          this.dispatchMessageToIframe({
            type: "ui-lifecycle-iframe-ready"
          });
          resolve();
        }, this.config.timeout)
      });
    });
    this.config.logger.log("[MCP Apps Adapter] Sending ui/initialize request with id:", jsonRpcId);
    this.sendJsonRpcRequest(jsonRpcId, "ui/initialize", {
      appInfo: {
        name: "mcp-ui-adapter",
        version: "1.0.0"
      },
      appCapabilities: {},
      protocolVersion: PROTOCOL_VERSION
    });
    this.config.logger.log("[MCP Apps Adapter] ui/initialize request sent");
    try {
      await initPromise;
    } catch (error) {
      this.config.logger.warn("[MCP Apps Adapter] Continuing despite initialization error");
    }
  }
  uninstall() {
    for (const request of this.pendingRequests.values()) {
      clearTimeout(request.timeoutId);
      request.reject(new Error("Adapter uninstalled"));
    }
    this.pendingRequests.clear();
    if (this.originalPostMessage && this.parentWindow) {
      try {
        this.parentWindow.postMessage = this.originalPostMessage;
        this.config.logger.log("[MCP Apps Adapter] Restored original parent.postMessage");
      } catch (error) {
        this.config.logger.error("[MCP Apps Adapter] Failed to restore original postMessage:", error);
      }
    }
    window.removeEventListener("message", this.handleHostMessage.bind(this));
    this.config.logger.log("[MCP Apps Adapter] Adapter uninstalled");
  }
  patchPostMessage() {
    this.originalPostMessage = this.parentWindow?.postMessage.bind(this.parentWindow) ?? null;
    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
      if (this.isMCPUIMessage(message)) {
        const mcpMessage = message;
        this.config.logger.debug("[MCP Apps Adapter] Intercepted MCP-UI message:", mcpMessage.type);
        this.handleMCPUIMessage(mcpMessage);
      } else {
        if (this.originalPostMessage) {
          if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
            const targetOrigin = targetOriginOrOptions ?? "*";
            this.originalPostMessage(message, targetOrigin, transfer);
          } else {
            this.originalPostMessage(message, targetOriginOrOptions);
          }
        }
      }
    };
    try {
      if (this.parentWindow) {
        this.parentWindow.postMessage = postMessageInterceptor;
      }
    } catch (error) {
      this.config.logger.error("[MCP Apps Adapter] Failed to monkey-patch parent.postMessage:", error);
    }
  }
  isMCPUIMessage(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const msg = message;
    return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
  }
  /**
   * Handles messages coming from the Host (JSON-RPC) and translates them to MCP-UI messages
   * 
   * MCP Apps SEP protocol methods (from @modelcontextprotocol/ext-apps):
   * - ui/notifications/tool-input: Complete tool arguments
   * - ui/notifications/tool-input-partial: Streaming partial tool arguments
   * - ui/notifications/tool-result: Tool execution results
   * - ui/notifications/host-context-changed: Theme, viewport, locale changes
   * - ui/notifications/size-change: Size change notifications (bidirectional)
   */
  handleHostMessage(event) {
    const data = event.data;
    if (!data || typeof data !== "object" || !data.jsonrpc) {
      return;
    }
    this.config.logger.debug("[MCP Apps Adapter] Received JSON-RPC message:", data);
    if (data.method) {
      switch (data.method) {
        case "ui/notifications/tool-input":
          this.currentRenderData.toolInput = data.params?.arguments;
          this.sendRenderData();
          break;
        case "ui/notifications/tool-input-partial":
          this.currentRenderData.toolInput = data.params?.arguments;
          this.sendRenderData();
          break;
        case "ui/notifications/tool-result":
          this.currentRenderData.toolOutput = data.params;
          this.sendRenderData();
          break;
        case "ui/notifications/host-context-changed":
          if (data.params?.theme)
            this.currentRenderData.theme = data.params.theme;
          if (data.params?.displayMode)
            this.currentRenderData.displayMode = data.params.displayMode;
          if (data.params?.locale)
            this.currentRenderData.locale = data.params.locale;
          if (data.params?.viewport?.maxHeight)
            this.currentRenderData.maxHeight = data.params.viewport.maxHeight;
          this.sendRenderData();
          break;
        case "ui/notifications/size-change":
          if (data.params?.height)
            this.currentRenderData.maxHeight = data.params.height;
          this.sendRenderData();
          break;
      }
    } else if (data.id) {
      const pendingRequest = this.pendingRequests.get(String(data.id));
      if (pendingRequest) {
        if (data.error) {
          pendingRequest.reject(new Error(data.error.message));
        } else {
          pendingRequest.resolve(data.result);
        }
        this.pendingRequests.delete(String(data.id));
        clearTimeout(pendingRequest.timeoutId);
        this.dispatchMessageToIframe({
          type: "ui-message-response",
          messageId: pendingRequest.messageId,
          // The original message ID from the App
          payload: {
            messageId: pendingRequest.messageId,
            response: data.result,
            error: data.error
          }
        });
      }
    }
  }
  /**
   * Handles messages coming from the App (MCP-UI) and translates them to Host (JSON-RPC)
   * 
   * MCP-UI message types translated to MCP Apps SEP:
   * - 'tool' -> tools/call request
   * - 'ui-size-change' -> ui/notifications/size-change notification
   * - 'notify' -> notifications/message notification (logging)
   * - 'link' -> ui/open-link request
   * - 'prompt' -> ui/message request
   * - 'ui-lifecycle-iframe-ready' -> ui/notifications/initialized notification
   */
  async handleMCPUIMessage(message) {
    const messageId = message.messageId || this.generateMessageId();
    this.dispatchMessageToIframe({
      type: "ui-message-received",
      payload: { messageId }
    });
    try {
      switch (message.type) {
        case "tool": {
          const { toolName, params } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "tool",
            resolve: () => {
            },
            // Handled in handleHostMessage
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, "tools/call", {
            name: toolName,
            arguments: params
          });
          break;
        }
        case "ui-size-change": {
          const { width, height } = message.payload;
          this.sendJsonRpcNotification("ui/notifications/size-change", { width, height });
          break;
        }
        case "notify": {
          const { message: msg } = message.payload;
          this.sendJsonRpcNotification("notifications/message", {
            level: "info",
            data: msg
          });
          break;
        }
        case "link": {
          const { url } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "link",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, "ui/open-link", { url });
          break;
        }
        case "prompt": {
          const { prompt } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "prompt",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, "ui/message", {
            role: "user",
            content: [{ type: "text", text: prompt }]
          });
          break;
        }
        case "ui-lifecycle-iframe-ready": {
          this.sendJsonRpcNotification("ui/notifications/initialized", {});
          this.sendRenderData();
          break;
        }
        case "ui-request-render-data": {
          this.sendRenderData(messageId);
          break;
        }
        case "intent": {
          const { intent, params } = message.payload;
          const jsonRpcId = this.generateJsonRpcId();
          this.pendingRequests.set(String(jsonRpcId), {
            messageId,
            type: "intent",
            resolve: () => {
            },
            reject: () => {
            },
            timeoutId: setTimeout(() => {
              this.pendingRequests.delete(String(jsonRpcId));
              this.dispatchMessageToIframe({
                type: "ui-message-response",
                messageId,
                payload: { messageId, error: "Timeout" }
              });
            }, this.config.timeout)
          });
          this.sendJsonRpcRequest(jsonRpcId, "ui/message", {
            role: "user",
            content: [{ type: "text", text: \`Intent: \${intent}. Parameters: \${JSON.stringify(params)}\` }]
          });
          break;
        }
      }
    } catch (error) {
      this.config.logger.error("[MCP Apps Adapter] Error handling message:", error);
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        messageId,
        payload: { messageId, error }
      });
    }
  }
  /**
   * Send current render data to the MCP-UI app
   * This mirrors the Apps SDK adapter's sendRenderData method
   */
  sendRenderData(requestMessageId) {
    this.dispatchMessageToIframe({
      type: "ui-lifecycle-iframe-render-data",
      messageId: requestMessageId,
      payload: {
        renderData: {
          toolInput: this.currentRenderData.toolInput,
          toolOutput: this.currentRenderData.toolOutput,
          widgetState: this.currentRenderData.widgetState,
          locale: this.currentRenderData.locale,
          theme: this.currentRenderData.theme,
          displayMode: this.currentRenderData.displayMode,
          maxHeight: this.currentRenderData.maxHeight
        }
      }
    });
  }
  sendJsonRpcRequest(id, method, params) {
    this.originalPostMessage?.({
      jsonrpc: "2.0",
      id,
      method,
      params
    }, "*");
  }
  sendJsonRpcNotification(method, params) {
    this.originalPostMessage?.({
      jsonrpc: "2.0",
      method,
      params
    }, "*");
  }
  dispatchMessageToIframe(data) {
    const event = new MessageEvent("message", {
      data,
      origin: window.location.origin,
      // Same origin since we are inside the iframe
      source: window
    });
    window.dispatchEvent(event);
  }
  generateMessageId() {
    return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
  }
  generateJsonRpcId() {
    return ++this.messageIdCounter;
  }
}
let adapterInstance = null;
function initAdapter(config) {
  if (adapterInstance) {
    console.warn("[MCP Apps Adapter] Adapter already initialized");
    return true;
  }
  adapterInstance = new McpAppsAdapter(config);
  return adapterInstance.install();
}
function uninstallAdapter() {
  if (adapterInstance) {
    adapterInstance.uninstall();
    adapterInstance = null;
  }
}
`;
function l(e) {
  const t = e ? {
    timeout: e.timeout
  } : {}, n = JSON.stringify(t);
  return `
<script>
(function() {
  'use strict';
  
  ${g}
  
  if (typeof window !== 'undefined') {
    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {
      console.warn('[MCP Apps Adapter] Adapter runtime not found. Adapter will not activate.');
      return;
    }
    
    if (!window.MCP_APPS_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter(${n});
    }
    
    window.McpAppsAdapter = {
      init: initAdapter,
      initWithConfig: () => initAdapter(${n}),
      uninstall: uninstallAdapter,
    };
  }
})();
<\/script>
`.trim();
}
function r(e) {
  const t = { ...e.resourceProps ?? {} };
  if (e.uiMetadata || e.metadata) {
    const n = Object.fromEntries(
      Object.entries(e.uiMetadata ?? {}).map(([i, s]) => [
        `${o}${i}`,
        s
      ])
    );
    t._meta = {
      ...n,
      ...e.metadata ?? {},
      ...t._meta ?? {}
    };
  }
  return t;
}
function c(e) {
  if (typeof Buffer < "u")
    return Buffer.from(e, "utf-8").toString("base64");
  if (typeof TextEncoder < "u" && typeof btoa < "u") {
    const n = new TextEncoder().encode(e);
    let i = "";
    const s = 8192;
    for (let a = 0; a < n.length; a += s)
      i += String.fromCharCode(...n.slice(a, a + s));
    return btoa(i);
  } else {
    console.warn(
      "MCP-UI SDK: Buffer API and TextEncoder/btoa not available. Base64 encoding might not be UTF-8 safe."
    );
    try {
      return btoa(e);
    } catch {
      throw new Error(
        "MCP-UI SDK: Suitable UTF-8 to Base64 encoding method not found, and fallback btoa failed."
      );
    }
  }
}
function u(e) {
  if (e) {
    if (e.appsSdk?.enabled)
      return e.appsSdk.mimeType ?? "text/html+skybridge";
    if (e.mcpApps?.enabled)
      return "text/html+mcp";
  }
}
function m(e, t) {
  if (!t)
    return e;
  const n = [];
  if (t.appsSdk?.enabled) {
    const a = p(t.appsSdk.config);
    n.push(a);
  }
  if (t.mcpApps?.enabled) {
    const a = l(t.mcpApps.config);
    n.push(a);
  }
  if (n.length === 0)
    return e;
  const i = n.join(`
`);
  let s;
  return e.includes("<head>") ? s = e.replace("<head>", `<head>
${i}`) : e.includes("<html>") ? s = e.replace("<html>", `<html>
<head>
${i}
</head>`) : s = `${i}
${e}`, s;
}
function f(e) {
  let t, n;
  if (e.content.type === "rawHtml") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'rawHtml'.");
    if (t = e.content.htmlString, typeof t != "string")
      throw new Error(
        "MCP-UI SDK: content.htmlString must be provided as a string when content.type is 'rawHtml'."
      );
    e.adapters ? (t = m(t, e.adapters), n = u(e.adapters) ?? "text/html") : n = "text/html";
  } else if (e.content.type === "externalUrl") {
    if (!e.uri.startsWith("ui://"))
      throw new Error(
        "MCP-UI SDK: URI must start with 'ui://' when content.type is 'externalUrl'."
      );
    const s = e.content.iframeUrl;
    if (typeof s != "string")
      throw new Error(
        "MCP-UI SDK: content.iframeUrl must be provided as a string when content.type is 'externalUrl'."
      );
    t = s, n = "text/uri-list";
  } else if (e.content.type === "remoteDom") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'remoteDom'.");
    if (t = e.content.script, typeof t != "string")
      throw new Error(
        "MCP-UI SDK: content.script must be provided as a string when content.type is 'remoteDom'."
      );
    n = `application/vnd.mcp-ui.remote-dom+javascript; framework=${e.content.framework}`;
  } else {
    const s = e.content;
    throw new Error(`MCP-UI SDK: Invalid content.type specified: ${s}`);
  }
  let i;
  switch (e.encoding) {
    case "text":
      i = {
        uri: e.uri,
        mimeType: n,
        text: t,
        ...r(e)
      };
      break;
    case "blob":
      i = {
        uri: e.uri,
        mimeType: n,
        blob: c(t),
        ...r(e)
      };
      break;
    default: {
      const s = e.encoding;
      throw new Error(`MCP-UI SDK: Invalid encoding type: ${s}`);
    }
  }
  return {
    type: "resource",
    resource: i,
    ...e.embeddedResourceProps ?? {}
  };
}
function I(e) {
  window.parent && window.parent.postMessage(e, "*");
}
const w = {
  UI_MESSAGE_RECEIVED: "ui-message-received",
  UI_MESSAGE_RESPONSE: "ui-message-response",
  UI_SIZE_CHANGE: "ui-size-change",
  UI_LIFECYCLE_IFRAME_READY: "ui-lifecycle-iframe-ready",
  UI_LIFECYCLE_IFRAME_RENDER_DATA: "ui-lifecycle-iframe-render-data",
  UI_RAWHTML_CONTENT: "ui-html-content"
}, M = {
  WAIT_FOR_RENDER_DATA: "waitForRenderData"
};
function y(e, t) {
  return {
    type: "tool",
    payload: {
      toolName: e,
      params: t
    }
  };
}
function A(e) {
  return {
    type: "prompt",
    payload: {
      prompt: e
    }
  };
}
function R(e) {
  return {
    type: "link",
    payload: {
      url: e
    }
  };
}
function P(e, t) {
  return {
    type: "intent",
    payload: {
      intent: e,
      params: t
    }
  };
}
function S(e) {
  return {
    type: "notify",
    payload: {
      message: e
    }
  };
}
export {
  w as InternalMessageType,
  h as RESOURCE_URI_META_KEY,
  M as ReservedUrlParams,
  f as createUIResource,
  u as getAdapterMimeType,
  p as getAppsSdkAdapterScript,
  l as getMcpAppsAdapterScript,
  I as postUIActionResult,
  P as uiActionResultIntent,
  R as uiActionResultLink,
  S as uiActionResultNotification,
  A as uiActionResultPrompt,
  y as uiActionResultToolCall,
  m as wrapHtmlWithAdapters
};
//# sourceMappingURL=index.mjs.map
