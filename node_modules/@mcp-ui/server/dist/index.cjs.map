{"version":3,"file":"index.cjs","sources":["../src/types.ts","../src/adapters/appssdk/adapter-runtime.bundled.ts","../src/adapters/appssdk/adapter.ts","../src/adapters/mcp-apps/adapter-runtime.bundled.ts","../src/adapters/mcp-apps/adapter.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import type { EmbeddedResource, Resource } from '@modelcontextprotocol/sdk/types.js';\nimport type { McpAppsAdapterConfig } from './adapters/mcp-apps/types.js';\n\n// Primary identifier for the resource. Starts with ui://`\nexport type URI = `ui://${string}`;\n\n/**\n * The key used in tool._meta to link a tool to its UI resource.\n * MCP Apps hosts look for this key to find the associated UI resource URI.\n * \n * This value matches the constant defined in the official @modelcontextprotocol/ext-apps\n * package, but is defined locally to avoid adding a runtime dependency for a simple string constant.\n * \n * @see https://github.com/modelcontextprotocol/ext-apps\n */\nexport const RESOURCE_URI_META_KEY = 'ui/resourceUri' as const;\n\n// text/html for rawHtml content, text/uri-list for externalUrl content\nexport type MimeType =\n  | 'text/html'\n  | 'text/html+mcp'\n  | 'text/html+skybridge'\n  | 'text/uri-list'\n  | 'application/vnd.mcp-ui.remote-dom+javascript; framework=react'\n  | 'application/vnd.mcp-ui.remote-dom+javascript; framework=webcomponents';\n\nexport type HTMLTextContent = {\n  uri: URI;\n  mimeType: MimeType;\n  text: string; // HTML content (for mimeType `text/html`), or iframe URL (for mimeType `text/uri-list`)\n  blob?: never;\n  _meta?: Record<string, unknown>;\n};\n\nexport type Base64BlobContent = {\n  uri: URI;\n  mimeType: MimeType;\n  blob: string; //  Base64 encoded HTML content (for mimeType `text/html`), or iframe URL (for mimeType `text/uri-list`)\n  text?: never;\n  _meta?: Record<string, unknown>;\n};\n\nexport type ResourceContentPayload =\n  | { type: 'rawHtml'; htmlString: string }\n  | { type: 'externalUrl'; iframeUrl: string }\n  | {\n      type: 'remoteDom';\n      script: string;\n      framework: 'react' | 'webcomponents';\n    };\n\nexport interface CreateUIResourceOptions {\n  uri: URI;\n  content: ResourceContentPayload;\n  encoding: 'text' | 'blob';\n  // specific mcp-ui metadata\n  uiMetadata?: UIResourceMetadata;\n  // additional metadata to be passed on _meta\n  metadata?: Record<string, unknown>;\n  // additional resource props to be passed on the resource itself\n  resourceProps?: UIResourceProps;\n  // additional resource props to be passed on the top-level embedded resource (i.e. annotations)\n  embeddedResourceProps?: EmbeddedUIResourceProps;\n  // Adapters for different environments (e.g., Apps SDK)\n  adapters?: AdaptersConfig;\n}\n\n/**\n * Configuration for adapters - only ONE adapter can be enabled at a time.\n * Each adapter produces a different MIME type, and resources can only have one MIME type.\n * \n * Use one of these configurations:\n * - `{ appsSdk: { enabled: true, ... } }` for ChatGPT/Apps SDK hosts\n * - `{ mcpApps: { enabled: true, ... } }` for MCP Apps SEP hosts\n * \n * @example Valid configurations\n * ```ts\n * // ✓ Apps SDK adapter only\n * const config1: AdaptersConfig = { appsSdk: { enabled: true } };\n * \n * // ✓ MCP Apps adapter only\n * const config2: AdaptersConfig = { mcpApps: { enabled: true } };\n * \n * // ✓ No adapters\n * const config3: AdaptersConfig = {};\n * ```\n * \n * @example Invalid configuration (TypeScript error)\n * ```ts\n * // ✗ Both adapters specified - compile-time error:\n * // \"Type '{ appsSdk: ...; mcpApps: ...; }' is not assignable to type 'AdaptersConfig'\"\n * const invalid: AdaptersConfig = {\n *   appsSdk: { enabled: true },\n *   mcpApps: { enabled: true }  // Error: mcpApps is 'never' when appsSdk is set\n * };\n * ```\n */\nexport type AdaptersConfig =\n  | { appsSdk: AppsSdkAdapterOptions; mcpApps?: never }\n  | { mcpApps: McpAppsAdapterOptions; appsSdk?: never }\n  | { appsSdk?: undefined; mcpApps?: undefined };\n\n/**\n * Configuration options for Apps SDK adapter\n */\nexport interface AppsSdkAdapterOptions {\n  /**\n   * Whether to enable the Apps SDK adapter.\n   * When enabled, the adapter script will be automatically injected into HTML content,\n   * allowing MCP-UI widgets to work in Apps SDK environments (e.g., ChatGPT).\n   * @default false\n   */\n  enabled: boolean;\n\n  /**\n   * Custom configuration for the adapter\n   */\n  config?: {\n    /**\n     * How to handle 'intent' messages (defaults to 'prompt')\n     * - 'prompt': Convert to sendFollowupTurn with intent description\n     * - 'ignore': Log and acknowledge but take no action\n     */\n    intentHandling?: 'prompt' | 'ignore';\n\n    /**\n     * Timeout in milliseconds for async operations (defaults to 30000)\n     */\n    timeout?: number;\n\n    /**\n     * Origin to use when dispatching MessageEvents to the iframe (defaults to window.location.origin)\n     */\n    hostOrigin?: string;\n  };\n\n  /**\n   * MIME type to use when this adapter is enabled.\n   * @default 'text/html+skybridge'\n   */\n  mimeType?: string;\n}\n\n/**\n * Configuration options for MCP Apps adapter\n */\nexport interface McpAppsAdapterOptions {\n  /**\n   * Whether to enable the MCP Apps adapter.\n   * When enabled, the adapter script will be automatically injected into HTML content,\n   * allowing existing MCP-UI widgets to work in new MCP Apps hosts.\n   * @default false\n   */\n  enabled: boolean;\n\n  /**\n   * Custom configuration for the adapter\n   */\n  config?: McpAppsAdapterConfig;\n}\n\nexport type UIResourceProps = Omit<Partial<Resource>, 'uri' | 'mimeType'>;\nexport type EmbeddedUIResourceProps = Omit<Partial<EmbeddedResource>, 'resource' | 'type'>;\n\nexport const UIMetadataKey = {\n  PREFERRED_FRAME_SIZE: 'preferred-frame-size',\n  INITIAL_RENDER_DATA: 'initial-render-data',\n} as const;\n\nexport const UI_METADATA_PREFIX = 'mcpui.dev/ui-';\n\nexport type UIResourceMetadata = {\n  [UIMetadataKey.PREFERRED_FRAME_SIZE]?: [string, string];\n  [UIMetadataKey.INITIAL_RENDER_DATA]?: Record<string, unknown>;\n};\n\nexport type UIActionType = 'tool' | 'prompt' | 'link' | 'intent' | 'notify';\n\ntype GenericActionMessage = {\n  messageId?: string;\n};\n\nexport type UIActionResultToolCall = GenericActionMessage & {\n  type: 'tool';\n  payload: {\n    toolName: string;\n    params: Record<string, unknown>;\n  };\n};\n\nexport type UIActionResultPrompt = GenericActionMessage & {\n  type: 'prompt';\n  payload: {\n    prompt: string;\n  };\n};\n\nexport type UIActionResultLink = GenericActionMessage & {\n  type: 'link';\n  payload: {\n    url: string;\n  };\n};\n\nexport type UIActionResultIntent = GenericActionMessage & {\n  type: 'intent';\n  payload: {\n    intent: string;\n    params: Record<string, unknown>;\n  };\n};\n\nexport type UIActionResultNotification = GenericActionMessage & {\n  type: 'notify';\n  payload: {\n    message: string;\n  };\n};\n\nexport type UIActionResult =\n  | UIActionResultToolCall\n  | UIActionResultPrompt\n  | UIActionResultLink\n  | UIActionResultIntent\n  | UIActionResultNotification;\n","// This file is auto-generated by scripts/bundle-adapter.js\n// Do not edit directly - modify adapter-runtime.ts instead\n\nexport const ADAPTER_RUNTIME_SCRIPT = \"var __defProp = Object.defineProperty;\\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\\nvar __publicField = (obj, key, value) => {\\n  __defNormalProp(obj, typeof key !== \\\"symbol\\\" ? key + \\\"\\\" : key, value);\\n  return value;\\n};\\nclass MCPUIAppsSdkAdapter {\\n  constructor(config = {}) {\\n    __publicField(this, \\\"config\\\");\\n    __publicField(this, \\\"pendingRequests\\\", /* @__PURE__ */ new Map());\\n    __publicField(this, \\\"messageIdCounter\\\", 0);\\n    __publicField(this, \\\"originalPostMessage\\\", null);\\n    this.config = {\\n      logger: config.logger || console,\\n      hostOrigin: config.hostOrigin || window.location.origin,\\n      timeout: config.timeout || 3e4,\\n      intentHandling: config.intentHandling || \\\"prompt\\\"\\n    };\\n  }\\n  /**\\n   * Initialize the adapter and monkey-patch postMessage if Apps SDK is present\\n   */\\n  install() {\\n    if (!window.openai) {\\n      this.config.logger.warn(\\\"[MCPUI-Apps SDK Adapter] window.openai not detected. Adapter will not activate.\\\");\\n      return false;\\n    }\\n    this.config.logger.log(\\\"[MCPUI-Apps SDK Adapter] Initializing adapter...\\\");\\n    this.patchPostMessage();\\n    this.setupAppsSdkEventListeners();\\n    this.sendRenderData();\\n    this.config.logger.log(\\\"[MCPUI-Apps SDK Adapter] Adapter initialized successfully\\\");\\n    return true;\\n  }\\n  /**\\n   * Clean up pending requests and restore original postMessage\\n   */\\n  uninstall() {\\n    for (const request of this.pendingRequests.values()) {\\n      clearTimeout(request.timeoutId);\\n      request.reject(new Error(\\\"Adapter uninstalled\\\"));\\n    }\\n    this.pendingRequests.clear();\\n    if (this.originalPostMessage) {\\n      try {\\n        const parentWindow = window.parent ?? null;\\n        if (parentWindow) {\\n          parentWindow.postMessage = this.originalPostMessage;\\n        }\\n        this.config.logger.log(\\\"[MCPUI-Apps SDK Adapter] Restored original parent.postMessage\\\");\\n      } catch (error) {\\n        this.config.logger.error(\\\"[MCPUI-Apps SDK Adapter] Failed to restore original postMessage:\\\", error);\\n      }\\n    }\\n    this.config.logger.log(\\\"[MCPUI-Apps SDK Adapter] Adapter uninstalled\\\");\\n  }\\n  /**\\n   * Monkey-patch parent.postMessage to intercept MCP-UI messages\\n   * and forward non-MCP-UI messages to the original postMessage\\n   */\\n  patchPostMessage() {\\n    const parentWindow = window.parent ?? null;\\n    this.originalPostMessage = parentWindow?.postMessage?.bind(parentWindow) ?? null;\\n    if (!this.originalPostMessage) {\\n      this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] parent.postMessage does not exist, installing shim only\\\");\\n    } else {\\n      this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] Monkey-patching parent.postMessage to intercept MCP-UI messages\\\");\\n    }\\n    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {\\n      if (this.isMCPUIMessage(message)) {\\n        const mcpMessage = message;\\n        this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] Intercepted MCP-UI message:\\\", mcpMessage.type);\\n        this.handleMCPUIMessage(mcpMessage);\\n      } else {\\n        if (this.originalPostMessage) {\\n          this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] Forwarding non-MCP-UI message to original postMessage\\\");\\n          if (typeof targetOriginOrOptions === \\\"string\\\" || targetOriginOrOptions === void 0) {\\n            const targetOrigin = targetOriginOrOptions ?? \\\"*\\\";\\n            this.originalPostMessage(message, targetOrigin, transfer);\\n          } else {\\n            this.originalPostMessage(message, targetOriginOrOptions);\\n          }\\n        } else {\\n          this.config.logger.warn(\\\"[MCPUI-Apps SDK Adapter] No original postMessage to forward to, ignoring message:\\\", message);\\n        }\\n      }\\n    };\\n    try {\\n      if (parentWindow) {\\n        parentWindow.postMessage = postMessageInterceptor;\\n      }\\n    } catch (error) {\\n      this.config.logger.error(\\\"[MCPUI-Apps SDK Adapter] Failed to monkey-patch parent.postMessage:\\\", error);\\n    }\\n  }\\n  /**\\n   * Check if a message is an MCP-UI protocol message\\n   */\\n  isMCPUIMessage(message) {\\n    if (!message || typeof message !== \\\"object\\\") {\\n      return false;\\n    }\\n    const msg = message;\\n    return typeof msg.type === \\\"string\\\" && (msg.type.startsWith(\\\"ui-\\\") || [\\\"tool\\\", \\\"prompt\\\", \\\"intent\\\", \\\"notify\\\", \\\"link\\\"].includes(msg.type));\\n  }\\n  /**\\n   * Handle incoming MCP-UI messages and translate to Apps SDK actions\\n   */\\n  async handleMCPUIMessage(message) {\\n    this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] Received MCPUI message:\\\", message.type);\\n    try {\\n      switch (message.type) {\\n        case \\\"tool\\\":\\n          await this.handleToolMessage(message);\\n          break;\\n        case \\\"prompt\\\":\\n          await this.handlePromptMessage(message);\\n          break;\\n        case \\\"intent\\\":\\n          await this.handleIntentMessage(message);\\n          break;\\n        case \\\"notify\\\":\\n          await this.handleNotifyMessage(message);\\n          break;\\n        case \\\"link\\\":\\n          await this.handleLinkMessage(message);\\n          break;\\n        case \\\"ui-lifecycle-iframe-ready\\\":\\n          this.sendRenderData();\\n          break;\\n        case \\\"ui-request-render-data\\\":\\n          this.sendRenderData(message.messageId);\\n          break;\\n        case \\\"ui-size-change\\\":\\n          this.handleSizeChange(message);\\n          break;\\n        case \\\"ui-request-data\\\":\\n          this.handleRequestData(message);\\n          break;\\n        default:\\n          this.config.logger.warn(\\\"[MCPUI-Apps SDK Adapter] Unknown message type:\\\", message.type);\\n      }\\n    } catch (error) {\\n      this.config.logger.error(\\\"[MCPUI-Apps SDK Adapter] Error handling message:\\\", error);\\n      if (message.messageId) {\\n        this.sendErrorResponse(message.messageId, error);\\n      }\\n    }\\n  }\\n  /**\\n   * Handle 'tool' message - call Apps SDK tool\\n   */\\n  async handleToolMessage(message) {\\n    if (message.type !== \\\"tool\\\")\\n      return;\\n    const { toolName, params } = message.payload;\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.sendAcknowledgment(messageId);\\n    try {\\n      if (!window.openai?.callTool) {\\n        throw new Error(\\\"Tool calling is not supported in this environment\\\");\\n      }\\n      const result = await this.withTimeout(\\n        window.openai.callTool(toolName, params),\\n        messageId\\n      );\\n      this.sendSuccessResponse(messageId, result);\\n    } catch (error) {\\n      this.sendErrorResponse(messageId, error);\\n    }\\n  }\\n  /**\\n   * Handle 'prompt' message - send followup turn\\n   */\\n  async handlePromptMessage(message) {\\n    if (message.type !== \\\"prompt\\\")\\n      return;\\n    const prompt = message.payload.prompt;\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.sendAcknowledgment(messageId);\\n    try {\\n      if (!window.openai?.sendFollowUpMessage) {\\n        throw new Error(\\\"Followup turns are not supported in this environment\\\");\\n      }\\n      await this.withTimeout(\\n        window.openai.sendFollowUpMessage({ prompt }),\\n        messageId\\n      );\\n      this.sendSuccessResponse(messageId, { success: true });\\n    } catch (error) {\\n      this.sendErrorResponse(messageId, error);\\n    }\\n  }\\n  /**\\n   * Handle 'intent' message - convert to prompt or ignore based on config\\n   */\\n  async handleIntentMessage(message) {\\n    if (message.type !== \\\"intent\\\")\\n      return;\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.sendAcknowledgment(messageId);\\n    if (this.config.intentHandling === \\\"ignore\\\") {\\n      this.config.logger.log(\\\"[MCPUI-Apps SDK Adapter] Intent ignored:\\\", message.payload.intent);\\n      this.sendSuccessResponse(messageId, { ignored: true });\\n      return;\\n    }\\n    const { intent, params } = message.payload;\\n    const prompt = `${intent}${params ? `: ${JSON.stringify(params)}` : \\\"\\\"}`;\\n    try {\\n      if (!window.openai?.sendFollowUpMessage) {\\n        throw new Error(\\\"Followup turns are not supported in this environment\\\");\\n      }\\n      await this.withTimeout(\\n        window.openai.sendFollowUpMessage({ prompt }),\\n        messageId\\n      );\\n      this.sendSuccessResponse(messageId, { success: true });\\n    } catch (error) {\\n      this.sendErrorResponse(messageId, error);\\n    }\\n  }\\n  /**\\n   * Handle 'notify' message - log only\\n   */\\n  async handleNotifyMessage(message) {\\n    if (message.type !== \\\"notify\\\")\\n      return;\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.config.logger.log(\\\"[MCPUI-Apps SDK Adapter] Notification:\\\", message.payload.message);\\n    this.sendAcknowledgment(messageId);\\n    this.sendSuccessResponse(messageId, { acknowledged: true });\\n  }\\n  /**\\n   * Handle 'link' message - not supported in Apps SDK environments\\n   */\\n  async handleLinkMessage(message) {\\n    if (message.type !== \\\"link\\\")\\n      return;\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.sendAcknowledgment(messageId);\\n    this.sendErrorResponse(messageId, new Error(\\\"Navigation is not supported in Apps SDK environment\\\"));\\n  }\\n  /**\\n   * Handle size change - no-op in Apps SDK environment\\n   */\\n  handleSizeChange(message) {\\n    this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] Size change requested (no-op in Apps SDK):\\\", message.payload);\\n  }\\n  /**\\n   * Handle generic data request\\n   */\\n  handleRequestData(message) {\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.sendAcknowledgment(messageId);\\n    this.sendErrorResponse(messageId, new Error(\\\"Generic data requests not yet implemented\\\"));\\n  }\\n  /**\\n   * Setup listeners for Apps SDK events\\n   */\\n  setupAppsSdkEventListeners() {\\n    window.addEventListener(\\\"openai:set_globals\\\", () => {\\n      this.config.logger.debug(\\\"[MCPUI-Apps SDK Adapter] Globals updated\\\");\\n      this.sendRenderData();\\n    });\\n  }\\n  /**\\n   * Gather render data from Apps SDK and send to widget\\n   */\\n  sendRenderData(requestMessageId) {\\n    if (!window.openai)\\n      return;\\n    const renderData = {\\n      toolInput: window.openai.toolInput,\\n      toolOutput: window.openai.toolOutput,\\n      widgetState: window.openai.widgetState,\\n      locale: window.openai.locale || \\\"en-US\\\",\\n      theme: window.openai.theme || \\\"light\\\",\\n      displayMode: window.openai.displayMode || \\\"inline\\\",\\n      maxHeight: window.openai.maxHeight\\n    };\\n    this.dispatchMessageToIframe({\\n      type: \\\"ui-lifecycle-iframe-render-data\\\",\\n      messageId: requestMessageId,\\n      payload: { renderData }\\n    });\\n  }\\n  /**\\n   * Send acknowledgment for a message\\n   */\\n  sendAcknowledgment(messageId) {\\n    this.dispatchMessageToIframe({\\n      type: \\\"ui-message-received\\\",\\n      payload: { messageId }\\n    });\\n  }\\n  /**\\n   * Send success response\\n   */\\n  sendSuccessResponse(messageId, response) {\\n    this.dispatchMessageToIframe({\\n      type: \\\"ui-message-response\\\",\\n      payload: { messageId, response }\\n    });\\n  }\\n  /**\\n   * Send error response\\n   */\\n  sendErrorResponse(messageId, error) {\\n    const errorObj = error instanceof Error ? { message: error.message, name: error.name } : { message: String(error) };\\n    this.dispatchMessageToIframe({\\n      type: \\\"ui-message-response\\\",\\n      payload: { messageId, error: errorObj }\\n    });\\n  }\\n  /**\\n   * Dispatch a MessageEvent to the iframe (widget)\\n   * Simulates messages that would normally come from the parent/host\\n   */\\n  dispatchMessageToIframe(data) {\\n    const event = new MessageEvent(\\\"message\\\", {\\n      data,\\n      origin: this.config.hostOrigin,\\n      source: null\\n    });\\n    window.dispatchEvent(event);\\n  }\\n  /**\\n   * Wrap a promise with timeout\\n   */\\n  async withTimeout(promise, requestId) {\\n    return new Promise((resolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        this.pendingRequests.delete(requestId);\\n        reject(new Error(`Request timed out after ${this.config.timeout}ms`));\\n      }, this.config.timeout);\\n      this.pendingRequests.set(requestId, {\\n        messageId: requestId,\\n        type: \\\"generic\\\",\\n        resolve,\\n        reject,\\n        timeoutId\\n      });\\n      promise.then((result) => {\\n        clearTimeout(timeoutId);\\n        this.pendingRequests.delete(requestId);\\n        resolve(result);\\n      }).catch((error) => {\\n        clearTimeout(timeoutId);\\n        this.pendingRequests.delete(requestId);\\n        reject(error);\\n      });\\n    });\\n  }\\n  /**\\n   * Generate a unique message ID\\n   */\\n  generateMessageId() {\\n    return `adapter-${Date.now()}-${++this.messageIdCounter}`;\\n  }\\n}\\nlet adapterInstance = null;\\nfunction initAdapter(config) {\\n  if (adapterInstance) {\\n    console.warn(\\\"[MCPUI-Apps SDK Adapter] Adapter already initialized\\\");\\n    return true;\\n  }\\n  adapterInstance = new MCPUIAppsSdkAdapter(config);\\n  return adapterInstance.install();\\n}\\nfunction uninstallAdapter() {\\n  if (adapterInstance) {\\n    adapterInstance.uninstall();\\n    adapterInstance = null;\\n  }\\n}\\n\";\n","/**\n * MCP-UI to Apps SDK Adapter\n *\n * This module enables MCP-UI embeddable widgets to run in Apps SDK environments (e.g., ChatGPT)\n * by intercepting postMessage calls and translating them to the Apps SDK API (e.g., window.openai).\n * \n * The actual implementation is in adapter-runtime.ts (with full TypeScript support).\n * This file imports the pre-bundled version and injects it with configuration.\n */\n\nimport type { AppsSdkAdapterConfig } from './types.js';\n/*\n * The bundler generates both JavaScript and TypeScript variants of the bundled runtime.\n * We import the TypeScript file here so that TypeScript compilation works even when the\n * JavaScript output has not been generated yet (e.g., in tests).\n *\n * Runtime consumers will still resolve to the JavaScript build via package exports.\n */\nimport { ADAPTER_RUNTIME_SCRIPT } from './adapter-runtime.bundled';\n\n/**\n * Returns the complete adapter script as a string that can be injected into HTML.\n * This is the runtime code that will be executed in the browser.\n *\n * @param config - Optional configuration for the adapter\n * @returns A string containing the complete adapter initialization script\n */\nexport function getAppsSdkAdapterScript(config?: AppsSdkAdapterConfig): string {\n  const configJson = config ? JSON.stringify(config) : '{}';\n\n  // Wrap the bundled runtime with configuration and auto-init\n  return `\n<script>\n(function() {\n  'use strict';\n  \n  ${ADAPTER_RUNTIME_SCRIPT}\n  \n  // Override auto-init from runtime and initialize with provided config\n  if (typeof window !== 'undefined') {\n    // If the functions are not defined, just return, we can't do anything.\n    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {\n      console.warn('[MCPUI-Apps SDK Adapter] Adapter runtime not found with the correct methods. Adapter will not activate.')    \n      return;\n    }\n    \n    // If auto-init is enabled, initialize with config from server \n    if (!window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL) {\n      initAdapter(${configJson});\n    }\n    \n    // Expose functions globally\n    if (typeof window.MCPUIAppsSdkAdapter === 'undefined') {\n      window.MCPUIAppsSdkAdapter = {\n        init: initAdapter,\n        initWithConfig: () => initAdapter(${configJson}),\n        uninstall: uninstallAdapter,\n      };\n    }\n  }\n})();\n</script>\n`.trim();\n}\n","// This file is auto-generated by scripts/bundle-adapter.js\n// Do not edit directly - modify adapter-runtime.ts instead\n\nexport const ADAPTER_RUNTIME_SCRIPT = \"var __defProp = Object.defineProperty;\\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\\nvar __publicField = (obj, key, value) => {\\n  __defNormalProp(obj, typeof key !== \\\"symbol\\\" ? key + \\\"\\\" : key, value);\\n  return value;\\n};\\nconst PROTOCOL_VERSION = \\\"2025-11-21\\\";\\nclass McpAppsAdapter {\\n  constructor(config = {}) {\\n    __publicField(this, \\\"config\\\");\\n    __publicField(this, \\\"pendingRequests\\\", /* @__PURE__ */ new Map());\\n    __publicField(this, \\\"messageIdCounter\\\", 0);\\n    __publicField(this, \\\"originalPostMessage\\\", null);\\n    __publicField(this, \\\"parentWindow\\\", null);\\n    __publicField(this, \\\"hostCapabilities\\\", null);\\n    __publicField(this, \\\"hostContext\\\", null);\\n    __publicField(this, \\\"initialized\\\", false);\\n    // Current render data state (similar to window.openai in Apps SDK)\\n    __publicField(this, \\\"currentRenderData\\\", {});\\n    this.config = {\\n      logger: config.logger || console,\\n      timeout: config.timeout || 3e4\\n    };\\n  }\\n  install() {\\n    this.parentWindow = window.parent;\\n    this.config.logger.log(\\\"[MCP Apps Adapter] Checking parent window...\\\");\\n    this.config.logger.log(\\\"[MCP Apps Adapter] window.parent exists:\\\", !!this.parentWindow);\\n    this.config.logger.log(\\\"[MCP Apps Adapter] window.parent === window:\\\", this.parentWindow === window);\\n    if (!this.parentWindow || this.parentWindow === window) {\\n      this.config.logger.warn(\\\"[MCP Apps Adapter] No parent window detected. Adapter will not activate.\\\");\\n      return false;\\n    }\\n    this.config.logger.log(\\\"[MCP Apps Adapter] Initializing adapter...\\\");\\n    this.patchPostMessage();\\n    window.addEventListener(\\\"message\\\", this.handleHostMessage.bind(this));\\n    this.performInitialization();\\n    this.config.logger.log(\\\"[MCP Apps Adapter] Adapter initialized successfully\\\");\\n    return true;\\n  }\\n  /**\\n   * Performs the MCP Apps SEP initialization handshake:\\n   * 1. Send ui/initialize request with adapter info\\n   * 2. Receive host capabilities and context\\n   * 3. Send ui/notifications/initialized notification\\n   * 4. Dispatch ready event to MCP-UI app\\n   */\\n  async performInitialization() {\\n    const jsonRpcId = this.generateJsonRpcId();\\n    const initPromise = new Promise((resolve, reject) => {\\n      this.pendingRequests.set(String(jsonRpcId), {\\n        messageId: \\\"init\\\",\\n        type: \\\"init\\\",\\n        resolve: (result) => {\\n          const res = result;\\n          this.hostCapabilities = res?.hostCapabilities ?? null;\\n          this.hostContext = res?.hostContext ?? null;\\n          this.initialized = true;\\n          this.sendJsonRpcNotification(\\\"ui/notifications/initialized\\\", {});\\n          if (this.hostContext) {\\n            if (this.hostContext.theme)\\n              this.currentRenderData.theme = this.hostContext.theme;\\n            if (this.hostContext.displayMode)\\n              this.currentRenderData.displayMode = this.hostContext.displayMode;\\n            if (this.hostContext.locale)\\n              this.currentRenderData.locale = this.hostContext.locale;\\n            if (this.hostContext.viewport?.maxHeight)\\n              this.currentRenderData.maxHeight = this.hostContext.viewport.maxHeight;\\n          }\\n          this.sendRenderData();\\n          this.dispatchMessageToIframe({\\n            type: \\\"ui-lifecycle-iframe-ready\\\"\\n          });\\n          resolve();\\n        },\\n        reject: (error) => {\\n          this.config.logger.error(\\\"[MCP Apps Adapter] Initialization failed:\\\", error);\\n          reject(error);\\n        },\\n        timeoutId: setTimeout(() => {\\n          this.pendingRequests.delete(String(jsonRpcId));\\n          this.config.logger.warn(\\\"[MCP Apps Adapter] Initialization timed out, proceeding anyway\\\");\\n          this.dispatchMessageToIframe({\\n            type: \\\"ui-lifecycle-iframe-ready\\\"\\n          });\\n          resolve();\\n        }, this.config.timeout)\\n      });\\n    });\\n    this.config.logger.log(\\\"[MCP Apps Adapter] Sending ui/initialize request with id:\\\", jsonRpcId);\\n    this.sendJsonRpcRequest(jsonRpcId, \\\"ui/initialize\\\", {\\n      appInfo: {\\n        name: \\\"mcp-ui-adapter\\\",\\n        version: \\\"1.0.0\\\"\\n      },\\n      appCapabilities: {},\\n      protocolVersion: PROTOCOL_VERSION\\n    });\\n    this.config.logger.log(\\\"[MCP Apps Adapter] ui/initialize request sent\\\");\\n    try {\\n      await initPromise;\\n    } catch (error) {\\n      this.config.logger.warn(\\\"[MCP Apps Adapter] Continuing despite initialization error\\\");\\n    }\\n  }\\n  uninstall() {\\n    for (const request of this.pendingRequests.values()) {\\n      clearTimeout(request.timeoutId);\\n      request.reject(new Error(\\\"Adapter uninstalled\\\"));\\n    }\\n    this.pendingRequests.clear();\\n    if (this.originalPostMessage && this.parentWindow) {\\n      try {\\n        this.parentWindow.postMessage = this.originalPostMessage;\\n        this.config.logger.log(\\\"[MCP Apps Adapter] Restored original parent.postMessage\\\");\\n      } catch (error) {\\n        this.config.logger.error(\\\"[MCP Apps Adapter] Failed to restore original postMessage:\\\", error);\\n      }\\n    }\\n    window.removeEventListener(\\\"message\\\", this.handleHostMessage.bind(this));\\n    this.config.logger.log(\\\"[MCP Apps Adapter] Adapter uninstalled\\\");\\n  }\\n  patchPostMessage() {\\n    this.originalPostMessage = this.parentWindow?.postMessage.bind(this.parentWindow) ?? null;\\n    const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {\\n      if (this.isMCPUIMessage(message)) {\\n        const mcpMessage = message;\\n        this.config.logger.debug(\\\"[MCP Apps Adapter] Intercepted MCP-UI message:\\\", mcpMessage.type);\\n        this.handleMCPUIMessage(mcpMessage);\\n      } else {\\n        if (this.originalPostMessage) {\\n          if (typeof targetOriginOrOptions === \\\"string\\\" || targetOriginOrOptions === void 0) {\\n            const targetOrigin = targetOriginOrOptions ?? \\\"*\\\";\\n            this.originalPostMessage(message, targetOrigin, transfer);\\n          } else {\\n            this.originalPostMessage(message, targetOriginOrOptions);\\n          }\\n        }\\n      }\\n    };\\n    try {\\n      if (this.parentWindow) {\\n        this.parentWindow.postMessage = postMessageInterceptor;\\n      }\\n    } catch (error) {\\n      this.config.logger.error(\\\"[MCP Apps Adapter] Failed to monkey-patch parent.postMessage:\\\", error);\\n    }\\n  }\\n  isMCPUIMessage(message) {\\n    if (!message || typeof message !== \\\"object\\\") {\\n      return false;\\n    }\\n    const msg = message;\\n    return typeof msg.type === \\\"string\\\" && (msg.type.startsWith(\\\"ui-\\\") || [\\\"tool\\\", \\\"prompt\\\", \\\"intent\\\", \\\"notify\\\", \\\"link\\\"].includes(msg.type));\\n  }\\n  /**\\n   * Handles messages coming from the Host (JSON-RPC) and translates them to MCP-UI messages\\n   * \\n   * MCP Apps SEP protocol methods (from @modelcontextprotocol/ext-apps):\\n   * - ui/notifications/tool-input: Complete tool arguments\\n   * - ui/notifications/tool-input-partial: Streaming partial tool arguments\\n   * - ui/notifications/tool-result: Tool execution results\\n   * - ui/notifications/host-context-changed: Theme, viewport, locale changes\\n   * - ui/notifications/size-change: Size change notifications (bidirectional)\\n   */\\n  handleHostMessage(event) {\\n    const data = event.data;\\n    if (!data || typeof data !== \\\"object\\\" || !data.jsonrpc) {\\n      return;\\n    }\\n    this.config.logger.debug(\\\"[MCP Apps Adapter] Received JSON-RPC message:\\\", data);\\n    if (data.method) {\\n      switch (data.method) {\\n        case \\\"ui/notifications/tool-input\\\":\\n          this.currentRenderData.toolInput = data.params?.arguments;\\n          this.sendRenderData();\\n          break;\\n        case \\\"ui/notifications/tool-input-partial\\\":\\n          this.currentRenderData.toolInput = data.params?.arguments;\\n          this.sendRenderData();\\n          break;\\n        case \\\"ui/notifications/tool-result\\\":\\n          this.currentRenderData.toolOutput = data.params;\\n          this.sendRenderData();\\n          break;\\n        case \\\"ui/notifications/host-context-changed\\\":\\n          if (data.params?.theme)\\n            this.currentRenderData.theme = data.params.theme;\\n          if (data.params?.displayMode)\\n            this.currentRenderData.displayMode = data.params.displayMode;\\n          if (data.params?.locale)\\n            this.currentRenderData.locale = data.params.locale;\\n          if (data.params?.viewport?.maxHeight)\\n            this.currentRenderData.maxHeight = data.params.viewport.maxHeight;\\n          this.sendRenderData();\\n          break;\\n        case \\\"ui/notifications/size-change\\\":\\n          if (data.params?.height)\\n            this.currentRenderData.maxHeight = data.params.height;\\n          this.sendRenderData();\\n          break;\\n      }\\n    } else if (data.id) {\\n      const pendingRequest = this.pendingRequests.get(String(data.id));\\n      if (pendingRequest) {\\n        if (data.error) {\\n          pendingRequest.reject(new Error(data.error.message));\\n        } else {\\n          pendingRequest.resolve(data.result);\\n        }\\n        this.pendingRequests.delete(String(data.id));\\n        clearTimeout(pendingRequest.timeoutId);\\n        this.dispatchMessageToIframe({\\n          type: \\\"ui-message-response\\\",\\n          messageId: pendingRequest.messageId,\\n          // The original message ID from the App\\n          payload: {\\n            messageId: pendingRequest.messageId,\\n            response: data.result,\\n            error: data.error\\n          }\\n        });\\n      }\\n    }\\n  }\\n  /**\\n   * Handles messages coming from the App (MCP-UI) and translates them to Host (JSON-RPC)\\n   * \\n   * MCP-UI message types translated to MCP Apps SEP:\\n   * - 'tool' -> tools/call request\\n   * - 'ui-size-change' -> ui/notifications/size-change notification\\n   * - 'notify' -> notifications/message notification (logging)\\n   * - 'link' -> ui/open-link request\\n   * - 'prompt' -> ui/message request\\n   * - 'ui-lifecycle-iframe-ready' -> ui/notifications/initialized notification\\n   */\\n  async handleMCPUIMessage(message) {\\n    const messageId = message.messageId || this.generateMessageId();\\n    this.dispatchMessageToIframe({\\n      type: \\\"ui-message-received\\\",\\n      payload: { messageId }\\n    });\\n    try {\\n      switch (message.type) {\\n        case \\\"tool\\\": {\\n          const { toolName, params } = message.payload;\\n          const jsonRpcId = this.generateJsonRpcId();\\n          this.pendingRequests.set(String(jsonRpcId), {\\n            messageId,\\n            type: \\\"tool\\\",\\n            resolve: () => {\\n            },\\n            // Handled in handleHostMessage\\n            reject: () => {\\n            },\\n            timeoutId: setTimeout(() => {\\n              this.pendingRequests.delete(String(jsonRpcId));\\n              this.dispatchMessageToIframe({\\n                type: \\\"ui-message-response\\\",\\n                messageId,\\n                payload: { messageId, error: \\\"Timeout\\\" }\\n              });\\n            }, this.config.timeout)\\n          });\\n          this.sendJsonRpcRequest(jsonRpcId, \\\"tools/call\\\", {\\n            name: toolName,\\n            arguments: params\\n          });\\n          break;\\n        }\\n        case \\\"ui-size-change\\\": {\\n          const { width, height } = message.payload;\\n          this.sendJsonRpcNotification(\\\"ui/notifications/size-change\\\", { width, height });\\n          break;\\n        }\\n        case \\\"notify\\\": {\\n          const { message: msg } = message.payload;\\n          this.sendJsonRpcNotification(\\\"notifications/message\\\", {\\n            level: \\\"info\\\",\\n            data: msg\\n          });\\n          break;\\n        }\\n        case \\\"link\\\": {\\n          const { url } = message.payload;\\n          const jsonRpcId = this.generateJsonRpcId();\\n          this.pendingRequests.set(String(jsonRpcId), {\\n            messageId,\\n            type: \\\"link\\\",\\n            resolve: () => {\\n            },\\n            reject: () => {\\n            },\\n            timeoutId: setTimeout(() => {\\n              this.pendingRequests.delete(String(jsonRpcId));\\n              this.dispatchMessageToIframe({\\n                type: \\\"ui-message-response\\\",\\n                messageId,\\n                payload: { messageId, error: \\\"Timeout\\\" }\\n              });\\n            }, this.config.timeout)\\n          });\\n          this.sendJsonRpcRequest(jsonRpcId, \\\"ui/open-link\\\", { url });\\n          break;\\n        }\\n        case \\\"prompt\\\": {\\n          const { prompt } = message.payload;\\n          const jsonRpcId = this.generateJsonRpcId();\\n          this.pendingRequests.set(String(jsonRpcId), {\\n            messageId,\\n            type: \\\"prompt\\\",\\n            resolve: () => {\\n            },\\n            reject: () => {\\n            },\\n            timeoutId: setTimeout(() => {\\n              this.pendingRequests.delete(String(jsonRpcId));\\n              this.dispatchMessageToIframe({\\n                type: \\\"ui-message-response\\\",\\n                messageId,\\n                payload: { messageId, error: \\\"Timeout\\\" }\\n              });\\n            }, this.config.timeout)\\n          });\\n          this.sendJsonRpcRequest(jsonRpcId, \\\"ui/message\\\", {\\n            role: \\\"user\\\",\\n            content: [{ type: \\\"text\\\", text: prompt }]\\n          });\\n          break;\\n        }\\n        case \\\"ui-lifecycle-iframe-ready\\\": {\\n          this.sendJsonRpcNotification(\\\"ui/notifications/initialized\\\", {});\\n          this.sendRenderData();\\n          break;\\n        }\\n        case \\\"ui-request-render-data\\\": {\\n          this.sendRenderData(messageId);\\n          break;\\n        }\\n        case \\\"intent\\\": {\\n          const { intent, params } = message.payload;\\n          const jsonRpcId = this.generateJsonRpcId();\\n          this.pendingRequests.set(String(jsonRpcId), {\\n            messageId,\\n            type: \\\"intent\\\",\\n            resolve: () => {\\n            },\\n            reject: () => {\\n            },\\n            timeoutId: setTimeout(() => {\\n              this.pendingRequests.delete(String(jsonRpcId));\\n              this.dispatchMessageToIframe({\\n                type: \\\"ui-message-response\\\",\\n                messageId,\\n                payload: { messageId, error: \\\"Timeout\\\" }\\n              });\\n            }, this.config.timeout)\\n          });\\n          this.sendJsonRpcRequest(jsonRpcId, \\\"ui/message\\\", {\\n            role: \\\"user\\\",\\n            content: [{ type: \\\"text\\\", text: `Intent: ${intent}. Parameters: ${JSON.stringify(params)}` }]\\n          });\\n          break;\\n        }\\n      }\\n    } catch (error) {\\n      this.config.logger.error(\\\"[MCP Apps Adapter] Error handling message:\\\", error);\\n      this.dispatchMessageToIframe({\\n        type: \\\"ui-message-response\\\",\\n        messageId,\\n        payload: { messageId, error }\\n      });\\n    }\\n  }\\n  /**\\n   * Send current render data to the MCP-UI app\\n   * This mirrors the Apps SDK adapter's sendRenderData method\\n   */\\n  sendRenderData(requestMessageId) {\\n    this.dispatchMessageToIframe({\\n      type: \\\"ui-lifecycle-iframe-render-data\\\",\\n      messageId: requestMessageId,\\n      payload: {\\n        renderData: {\\n          toolInput: this.currentRenderData.toolInput,\\n          toolOutput: this.currentRenderData.toolOutput,\\n          widgetState: this.currentRenderData.widgetState,\\n          locale: this.currentRenderData.locale,\\n          theme: this.currentRenderData.theme,\\n          displayMode: this.currentRenderData.displayMode,\\n          maxHeight: this.currentRenderData.maxHeight\\n        }\\n      }\\n    });\\n  }\\n  sendJsonRpcRequest(id, method, params) {\\n    this.originalPostMessage?.({\\n      jsonrpc: \\\"2.0\\\",\\n      id,\\n      method,\\n      params\\n    }, \\\"*\\\");\\n  }\\n  sendJsonRpcNotification(method, params) {\\n    this.originalPostMessage?.({\\n      jsonrpc: \\\"2.0\\\",\\n      method,\\n      params\\n    }, \\\"*\\\");\\n  }\\n  dispatchMessageToIframe(data) {\\n    const event = new MessageEvent(\\\"message\\\", {\\n      data,\\n      origin: window.location.origin,\\n      // Same origin since we are inside the iframe\\n      source: window\\n    });\\n    window.dispatchEvent(event);\\n  }\\n  generateMessageId() {\\n    return `adapter-${Date.now()}-${++this.messageIdCounter}`;\\n  }\\n  generateJsonRpcId() {\\n    return ++this.messageIdCounter;\\n  }\\n}\\nlet adapterInstance = null;\\nfunction initAdapter(config) {\\n  if (adapterInstance) {\\n    console.warn(\\\"[MCP Apps Adapter] Adapter already initialized\\\");\\n    return true;\\n  }\\n  adapterInstance = new McpAppsAdapter(config);\\n  return adapterInstance.install();\\n}\\nfunction uninstallAdapter() {\\n  if (adapterInstance) {\\n    adapterInstance.uninstall();\\n    adapterInstance = null;\\n  }\\n}\\n\";\n","import type { McpAppsAdapterConfig } from './types.js';\n// @ts-expect-error - The bundled file is generated at build time\nimport { ADAPTER_RUNTIME_SCRIPT } from './adapter-runtime.bundled.ts';\n\nexport function getMcpAppsAdapterScript(config?: McpAppsAdapterConfig): string {\n  const serializableConfig = config ? {\n    timeout: config.timeout,\n  } : {};\n  const configJson = JSON.stringify(serializableConfig);\n\n  return `\n<script>\n(function() {\n  'use strict';\n  \n  ${ADAPTER_RUNTIME_SCRIPT}\n  \n  if (typeof window !== 'undefined') {\n    if (typeof initAdapter !== 'function' || typeof uninstallAdapter !== 'function') {\n      console.warn('[MCP Apps Adapter] Adapter runtime not found. Adapter will not activate.');\n      return;\n    }\n    \n    if (!window.MCP_APPS_ADAPTER_NO_AUTO_INSTALL) {\n      initAdapter(${configJson});\n    }\n    \n    window.McpAppsAdapter = {\n      init: initAdapter,\n      initWithConfig: () => initAdapter(${configJson}),\n      uninstall: uninstallAdapter,\n    };\n  }\n})();\n</script>\n`.trim();\n}\n\n","import type { CreateUIResourceOptions, UIResourceProps, AdaptersConfig } from './types.js';\nimport { UI_METADATA_PREFIX } from './types.js';\nimport { getAppsSdkAdapterScript } from './adapters/appssdk/adapter.js';\nimport { getMcpAppsAdapterScript } from './adapters/mcp-apps/adapter.js';\n\nexport function getAdditionalResourceProps(\n  resourceOptions: Partial<CreateUIResourceOptions>,\n): UIResourceProps {\n  const additionalResourceProps = { ...(resourceOptions.resourceProps ?? {}) } as UIResourceProps;\n\n  // prefix ui specific metadata with the prefix to be recognized by the client\n  if (resourceOptions.uiMetadata || resourceOptions.metadata) {\n    const uiPrefixedMetadata = Object.fromEntries(\n      Object.entries(resourceOptions.uiMetadata ?? {}).map(([key, value]) => [\n        `${UI_METADATA_PREFIX}${key}`,\n        value,\n      ]),\n    );\n    // allow user defined _meta to override ui metadata\n    additionalResourceProps._meta = {\n      ...uiPrefixedMetadata,\n      ...(resourceOptions.metadata ?? {}),\n      ...(additionalResourceProps._meta ?? {}),\n    };\n  }\n\n  return additionalResourceProps;\n}\n\n/**\n * Robustly encodes a UTF-8 string to Base64.\n * Uses Node.js Buffer if available, otherwise TextEncoder and btoa.\n * @param str The string to encode.\n * @returns Base64 encoded string.\n */\nexport function utf8ToBase64(str: string): string {\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str, 'utf-8').toString('base64');\n  } else if (typeof TextEncoder !== 'undefined' && typeof btoa !== 'undefined') {\n    const encoder = new TextEncoder();\n    const uint8Array = encoder.encode(str);\n    // Efficiently convert Uint8Array to binary string, handling large arrays in chunks\n    let binaryString = '';\n    // 8192 is a common chunk size used in JavaScript for performance reasons.\n    // It tends to align well with internal buffer sizes and memory page sizes,\n    // and it's small enough to avoid stack overflow errors with String.fromCharCode.\n    const CHUNK_SIZE = 8192;\n    for (let i = 0; i < uint8Array.length; i += CHUNK_SIZE) {\n      binaryString += String.fromCharCode(...uint8Array.slice(i, i + CHUNK_SIZE));\n    }\n    return btoa(binaryString);\n  } else {\n    console.warn(\n      'MCP-UI SDK: Buffer API and TextEncoder/btoa not available. Base64 encoding might not be UTF-8 safe.',\n    );\n    try {\n      return btoa(str);\n    } catch (e) {\n      throw new Error(\n        'MCP-UI SDK: Suitable UTF-8 to Base64 encoding method not found, and fallback btoa failed.',\n      );\n    }\n  }\n}\n\n/**\n * Determines the MIME type based on enabled adapters.\n *\n * @param adaptersConfig - Configuration for all adapters\n * @returns The MIME type to use, or undefined if no adapters are enabled\n */\nexport function getAdapterMimeType(adaptersConfig?: AdaptersConfig): string | undefined {\n  if (!adaptersConfig) {\n    return undefined;\n  }\n\n  // Apps SDK adapter\n  if (adaptersConfig.appsSdk?.enabled) {\n    return adaptersConfig.appsSdk.mimeType ?? 'text/html+skybridge';\n  }\n\n  // MCP Apps adapter uses text/html+mcp as per the ext-apps specification\n  if (adaptersConfig.mcpApps?.enabled) {\n    return 'text/html+mcp';\n  }\n\n  // Future adapters can be added here by checking for their config and returning their mime type.\n\n  return undefined;\n}\n\n/**\n * Wraps HTML content with enabled adapter scripts.\n * This allows the HTML to communicate with different platform environments.\n *\n * @param htmlContent - The HTML content to wrap\n * @param adaptersConfig - Configuration for all adapters\n * @returns The wrapped HTML content with adapter scripts injected\n */\nexport function wrapHtmlWithAdapters(\n  htmlContent: string,\n  adaptersConfig?: AdaptersConfig,\n): string {\n  if (!adaptersConfig) {\n    return htmlContent;\n  }\n\n  const adapterScripts: string[] = [];\n\n  // Apps SDK adapter\n  if (adaptersConfig.appsSdk?.enabled) {\n    const script = getAppsSdkAdapterScript(adaptersConfig.appsSdk.config);\n    adapterScripts.push(script);\n  }\n\n  // MCP Apps adapter\n  if (adaptersConfig.mcpApps?.enabled) {\n    const script = getMcpAppsAdapterScript(adaptersConfig.mcpApps.config);\n    adapterScripts.push(script);\n  }\n\n  // Future adapters can be added here by checking for their config and pushing their scripts to adapterScripts.\n\n  // If no adapters are enabled, return original HTML\n  if (adapterScripts.length === 0) {\n    return htmlContent;\n  }\n\n  // Combine all adapter scripts\n  const combinedScripts = adapterScripts.join('\\n');\n\n  let finalHtmlContent: string;\n\n  // If the HTML already has a <head> tag, inject the adapter scripts into it\n  if (htmlContent.includes('<head>')) {\n    finalHtmlContent = htmlContent.replace('<head>', `<head>\\n${combinedScripts}`);\n  }\n  // If the HTML has an <html> tag but no <head>, add a <head> with the adapter scripts\n  else if (htmlContent.includes('<html>')) {\n    finalHtmlContent = htmlContent.replace('<html>', `<html>\\n<head>\\n${combinedScripts}\\n</head>`);\n  }\n  // Otherwise, prepend the adapter scripts before the content\n  else {\n    finalHtmlContent = `${combinedScripts}\\n${htmlContent}`;\n  }\n\n  return finalHtmlContent;\n}\n\n","import {\n  Base64BlobContent,\n  CreateUIResourceOptions,\n  HTMLTextContent,\n  MimeType,\n  UIActionResult,\n  UIActionResultLink,\n  UIActionResultNotification,\n  UIActionResultPrompt,\n  UIActionResultIntent,\n  UIActionResultToolCall,\n} from './types.js';\nimport {\n  getAdditionalResourceProps,\n  utf8ToBase64,\n  wrapHtmlWithAdapters,\n  getAdapterMimeType,\n} from './utils.js';\n\nexport type UIResource = {\n  type: 'resource';\n  resource: HTMLTextContent | Base64BlobContent;\n  annotations?: Record<string, unknown>;\n  _meta?: Record<string, unknown>;\n};\n\n/**\n * Creates a UIResource.\n * This is the object that should be included in the 'content' array of a toolResult.\n * \n * @param options Configuration for the interactive resource.\n * @returns a UIResource\n */\nexport function createUIResource(\n  options: CreateUIResourceOptions,\n): UIResource {\n  let actualContentString: string;\n  let mimeType: MimeType;\n\n  if (options.content.type === 'rawHtml') {\n    if (!options.uri.startsWith('ui://')) {\n      throw new Error(\"MCP-UI SDK: URI must start with 'ui://' when content.type is 'rawHtml'.\");\n    }\n    actualContentString = options.content.htmlString;\n    if (typeof actualContentString !== 'string') {\n      throw new Error(\n        \"MCP-UI SDK: content.htmlString must be provided as a string when content.type is 'rawHtml'.\",\n      );\n    }\n\n    // Wrap with adapters if any are enabled\n    if (options.adapters) {\n      actualContentString = wrapHtmlWithAdapters(actualContentString, options.adapters);\n      // Use adapter's mime type if provided, otherwise fall back to 'text/html'\n      mimeType = (getAdapterMimeType(options.adapters) as MimeType) ?? 'text/html';\n    } else {\n      mimeType = 'text/html';\n    }\n  } else if (options.content.type === 'externalUrl') {\n    if (!options.uri.startsWith('ui://')) {\n      throw new Error(\n        \"MCP-UI SDK: URI must start with 'ui://' when content.type is 'externalUrl'.\",\n      );\n    }\n    const iframeUrl = options.content.iframeUrl;\n    if (typeof iframeUrl !== 'string') {\n      throw new Error(\n        \"MCP-UI SDK: content.iframeUrl must be provided as a string when content.type is 'externalUrl'.\",\n      );\n    }\n    actualContentString = iframeUrl;\n    mimeType = 'text/uri-list';\n  } else if (options.content.type === 'remoteDom') {\n    if (!options.uri.startsWith('ui://')) {\n      throw new Error(\"MCP-UI SDK: URI must start with 'ui://' when content.type is 'remoteDom'.\");\n    }\n    actualContentString = options.content.script;\n    if (typeof actualContentString !== 'string') {\n      throw new Error(\n        \"MCP-UI SDK: content.script must be provided as a string when content.type is 'remoteDom'.\",\n      );\n    }\n    mimeType = `application/vnd.mcp-ui.remote-dom+javascript; framework=${options.content.framework}`;\n  } else {\n    // This case should ideally be prevented by TypeScript's discriminated union checks\n    const exhaustiveCheckContent: never = options.content;\n    throw new Error(`MCP-UI SDK: Invalid content.type specified: ${exhaustiveCheckContent}`);\n  }\n\n  let resource: UIResource['resource'];\n\n  switch (options.encoding) {\n    case 'text':\n      resource = {\n        uri: options.uri,\n        mimeType: mimeType as MimeType,\n        text: actualContentString,\n        ...getAdditionalResourceProps(options),\n      };\n      break;\n    case 'blob':\n      resource = {\n        uri: options.uri,\n        mimeType: mimeType as MimeType,\n        blob: utf8ToBase64(actualContentString),\n        ...getAdditionalResourceProps(options),\n      };\n      break;\n    default: {\n      const exhaustiveCheck: never = options.encoding;\n      throw new Error(`MCP-UI SDK: Invalid encoding type: ${exhaustiveCheck}`);\n    }\n  }\n\n  return {\n    type: 'resource',\n    resource: resource,\n    ...(options.embeddedResourceProps ?? {}),\n  };\n}\n\nexport type {\n  CreateUIResourceOptions,\n  ResourceContentPayload,\n  UIActionResult,\n  AdaptersConfig,\n  AppsSdkAdapterOptions,\n} from './types.js';\n\n// Re-export the key used in tool metadata to link to a UI resource\nexport { RESOURCE_URI_META_KEY } from './types.js';\n\n// Export adapters\nexport { wrapHtmlWithAdapters, getAdapterMimeType } from './utils.js';\nexport * from './adapters/index.js';\n\nexport function postUIActionResult(result: UIActionResult): void {\n  if (window.parent) {\n    window.parent.postMessage(result, '*');\n  }\n}\n\nexport const InternalMessageType = {\n  UI_MESSAGE_RECEIVED: 'ui-message-received',\n  UI_MESSAGE_RESPONSE: 'ui-message-response',\n\n  UI_SIZE_CHANGE: 'ui-size-change',\n\n  UI_LIFECYCLE_IFRAME_READY: 'ui-lifecycle-iframe-ready',\n  UI_LIFECYCLE_IFRAME_RENDER_DATA: 'ui-lifecycle-iframe-render-data',\n  \n  UI_RAWHTML_CONTENT: 'ui-html-content',\n};\n\nexport const ReservedUrlParams = {\n  WAIT_FOR_RENDER_DATA: 'waitForRenderData',\n} as const;\n\nexport function uiActionResultToolCall(\n  toolName: string,\n  params: Record<string, unknown>,\n): UIActionResultToolCall {\n  return {\n    type: 'tool',\n    payload: {\n      toolName,\n      params,\n    },\n  };\n}\n\nexport function uiActionResultPrompt(prompt: string): UIActionResultPrompt {\n  return {\n    type: 'prompt',\n    payload: {\n      prompt,\n    },\n  };\n}\n\nexport function uiActionResultLink(url: string): UIActionResultLink {\n  return {\n    type: 'link',\n    payload: {\n      url,\n    },\n  };\n}\n\nexport function uiActionResultIntent(\n  intent: string,\n  params: Record<string, unknown>,\n): UIActionResultIntent {\n  return {\n    type: 'intent',\n    payload: {\n      intent,\n      params,\n    },\n  };\n}\n\nexport function uiActionResultNotification(message: string): UIActionResultNotification {\n  return {\n    type: 'notify',\n    payload: {\n      message,\n    },\n  };\n}\n"],"names":["RESOURCE_URI_META_KEY","UI_METADATA_PREFIX","ADAPTER_RUNTIME_SCRIPT","getAppsSdkAdapterScript","config","configJson","getMcpAppsAdapterScript","serializableConfig","getAdditionalResourceProps","resourceOptions","additionalResourceProps","uiPrefixedMetadata","key","value","utf8ToBase64","str","uint8Array","binaryString","CHUNK_SIZE","i","getAdapterMimeType","adaptersConfig","wrapHtmlWithAdapters","htmlContent","adapterScripts","script","combinedScripts","finalHtmlContent","createUIResource","options","actualContentString","mimeType","iframeUrl","exhaustiveCheckContent","resource","exhaustiveCheck","postUIActionResult","result","InternalMessageType","ReservedUrlParams","uiActionResultToolCall","toolName","params","uiActionResultPrompt","prompt","uiActionResultLink","url","uiActionResultIntent","intent","uiActionResultNotification","message"],"mappings":"gFAeO,MAAMA,EAAwB,iBA0JxBC,EAAqB,gBCtKrBC,EAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECwB/B,SAASC,EAAwBC,EAAuC,CAC7E,MAAMC,EAAaD,EAAS,KAAK,UAAUA,CAAM,EAAI,KAGrD,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA,IAKLF,CAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAYNG,CAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CAOcA,CAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOpD,KAAA,CACF,CC5DO,MAAMH,EAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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"}